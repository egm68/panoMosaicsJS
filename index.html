<!-- Needs webserver to run correctly -->
<!-- see https://threejs.org/docs/#manual/en/introduction/Installation for setup instructions (Option 1: Install with NPM and a build tool) -->
<!-- run: npx vite -->
<!-- open: http://localhost:5173/ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebGL/Three.js Image Compositing</title>
    <meta charset="utf-8">
    <style>
        body {
          background-color: #92a8d1;
        }
    </style>
    <script id="fullscreen-vert" type="x-shader/x-vertex">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 1.0, 1.0);
        }
    </script>
    <script id="fullscreen-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tex;

        void main() {
            vec3 diffuse = texture2D( tex, vUv ).rgb;
            gl_FragColor.rgb = diffuse;
            gl_FragColor.a = 1.0;
        }
    </script>
    <script id="blending-vert" type="x-shader/x-vertex">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="blending-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform sampler2D bgTex;
        uniform float resX;
        uniform float resY;
        uniform float alpha;
        uniform int highlight;
        uniform vec3 borderColor;

        void main() {
            // get color of current image
            vec3 color = texture2D( tex, vUv ).rgb;
            // texture coordinates of previous frame
            vec2 st = gl_FragCoord.xy / vec2(resX, resY);
            // get background color from texture (previous render target)
            vec3 bgColor = texture2D( bgTex, st).rgb;

            // this is a bit hacky (we assume that the background color is white)
            if( bgColor.x > 0.99 && bgColor.y > 0.99 && bgColor.z > 0.99 )
                // if the previous pixel has the background color: 
                //    render on top
                gl_FragColor.rgb = color;
            else
                // if the previous pixel does not have the background color: 
                //    blend with previous color
                gl_FragColor.rgb = bgColor * (1.0 - alpha) + color * alpha;

            // highlight pixels on the border of the image
            if (highlight == 1) {
                float borderX = 0.005;
                float borderY = (resX / resY) * borderX;
                // check if pixel is on the border
                if( vUv.s < borderX || vUv.s > 1.0 - borderX || vUv.t < borderY || vUv.t > 1.0 - borderY )
                    gl_FragColor.rgb = borderColor;
            }
            gl_FragColor.a = 1.0;
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // GUI parameters
        const params = {
            frameID: 0,
            color: 0xff0000,
            alpha: 0.5,
            saveImg: function() {
                var url = renderer.domElement.toDataURL("image/png");
                var link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('target', '_blank');
                link.setAttribute('download', 'panorama');
                link.click();
            },
        };

        // load json file
        var jsonData = await fetch("/corners_updated.json");
        var jsonCoords = await jsonData.json();
        // load images as textures
        var tex = [];
        var coordsX = [];
        var coordsY = [];
        var frameID = {};
        Object.entries(jsonCoords).forEach((entry) => {
            const [key, value] = entry;
            coordsX[key] = [ 
                value.corner_1_x,
                value.corner_2_x,
                value.corner_3_x,
                value.corner_4_x ];
            coordsY[key] = [ 
                value.corner_1_y,
                value.corner_2_y,
                value.corner_3_y,
                value.corner_4_y ];
            frameID[key] = value.frame_id;
            tex[key] = new THREE.TextureLoader().load( '/frames_updated/' + key.toString() + '.png' );
        });
        var imageCount = tex.length;
        // get min/max x/y values
        var minX = Math.min(...coordsX.map(item => Math.min.apply(null, item)));
        var maxX = Math.max(...coordsX.map(item => Math.max.apply(null, item)));
        var minY = Math.min(...coordsY.map(item => Math.min.apply(null, item)));
        var maxY = Math.max(...coordsY.map(item => Math.max.apply(null, item)));
        //console.log("X: " + (maxX - minX) + " Y: " + (maxY - minY))
        
        let renderer, camera, scene = [], material = [], controls, target = [];
        let stats;
        // scene, cam, and material for fullscreen quad rendering
        let fsScene, fsCamera, fsMaterial;

        // call initialize function only after loading image data
        init();
        animate();

        function init() {
            // fps counter (can be removed)
            stats = new Stats();
            document.body.appendChild( stats.dom );

            // WebGL renderer update
            renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );
            renderer.autoClear = false;
            renderer.setClearColor( 0xffffff, 1.0 );
            document.body.appendChild( renderer.domElement );

            // Create two render targets for ping-pong rendering
            setupRenderTargets();

            // Our scene
            setupScene();

            // Setup rendering step for fullscreen quad rendering (show render target texture)
            setupFullscreenQuadRendering();

            // resize render targets
            for (var i = 0; i < target.length; i++) {
                target[i].setSize( maxX - minX, maxY - minY );
            }
            // set renderer size to image size
            renderer.setSize( (maxX - minX) / 1.0, (maxY - minY) / 1.0 );
            
            // set up GUI
            const gui = new GUI( { width: 300 } );
            gui.add( params, 'frameID').name("Highlight Frame").min(0).max(imageCount).step(1);
            gui.addColor(params, 'color').name('Border Color');
            gui.add( params, 'alpha').name("Alpha").min(0.0).max(1.0).step(.01);
            gui.add( params, 'saveImg').name("Save Image");
            gui.open();
        }

        function setupRenderTargets() {
            // dispose of all previously declared render targets
            for (var i = 0; i < target.length; i++) {
                if ( target[i] ) target[i].dispose();
            }

            // first render target
            target[0] = new THREE.WebGLRenderTarget( maxX - minX, maxY - minY );
            target[0].texture.minFilter = THREE.LinearFilter;
            target[0].texture.magFilter = THREE.LinearFilter;

            // second render target
            target[1] = new THREE.WebGLRenderTarget( maxX - minX, maxY - minY );
            target[1].texture.minFilter = THREE.LinearFilter;
            target[1].texture.magFilter = THREE.LinearFilter;
        }

        function setupFullscreenQuadRendering() {
            // renders a texture on a full-screen qaud
            fsCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
            fsMaterial = new THREE.ShaderMaterial( {
                vertexShader: document.querySelector( '#fullscreen-vert' ).textContent.trim(),
                fragmentShader: document.querySelector( '#fullscreen-frag' ).textContent.trim(),
                uniforms: {
                    tex: { value: null }
                }
            } );
            const fsQuad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), fsMaterial );
            fsScene = new THREE.Scene();
            fsScene.add( fsQuad );
        }

        function setupScene() {
            
            camera = new THREE.OrthographicCamera( minX, maxX, minY, maxY, 0, -1 );
            
            // texture coordinates
            const uvcoords = new Float32Array( [
                0.0,  1.0,
                1.0,  0.0,
                1.0,  1.0,

                1.0,  0.0,
                0.0,  1.0,
                0.0,  0.0,
            ] );

            for( let i = 0; i < imageCount; i++) {
                scene[i] = new THREE.Scene();

                const vertices = new Float32Array( [
                    coordsX[i][0], coordsY[i][0], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 0
                    coordsX[i][2], coordsY[i][2], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 2
                    coordsX[i][1], coordsY[i][1], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 1

                    coordsX[i][2], coordsY[i][2], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 2
                    coordsX[i][0], coordsY[i][0], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 0
                    coordsX[i][3], coordsY[i][3], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 3
                ] );

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                geometry.setAttribute( 'uv', new THREE.BufferAttribute( uvcoords, 2 ) );
                material[i] = new THREE.ShaderMaterial( {
                    vertexShader: document.querySelector( '#blending-vert' ).textContent.trim(),
                    fragmentShader: document.querySelector( '#blending-frag' ).textContent.trim(),
                    uniforms: {
                        tex: { value: tex[i] },
                        bgTex: { value: null },
                        resX: { value: maxX - minX },
                        resY: { value: maxY - minY },
                        alpha: { value: params.alpha },
                        highlight: { value: 0 },
                        borderColor: { value: new THREE.Color(params.color)},
                    }
                } );
                material[i].side = THREE.DoubleSide;
                const quad = new THREE.Mesh( geometry, material[i] );
                scene[i].add( quad );
            }

        }

        function animate() {
            
            requestAnimationFrame( animate );

            // clear both render targets
            renderer.setRenderTarget( target[0] );
            renderer.clear();
            renderer.setRenderTarget( target[1] );
            renderer.clear();

            // render scene into target
            var currentTarget, lastTarget;
            for (var i = 0; i < imageCount; i++) {
                lastTarget = (i+1)%2;
                currentTarget = i%2;
                // set the current render target and clear it
                renderer.setRenderTarget( target[currentTarget] );
                renderer.clear();
                // render the previous results (full-screen quad)
                fsMaterial.uniforms.tex.value = target[lastTarget].texture;
                renderer.render( fsScene, fsCamera );
                // render the next image on top
                material[i].uniforms.bgTex.value = target[lastTarget].texture;
                material[i].uniforms.alpha.value = params.alpha;
                material[i].uniforms.highlight.value = (i == params.frameID - 1)? 1 : 0;
                material[i].uniforms.borderColor.value = new THREE.Color(params.color);
                renderer.render( scene[i], camera );
            }

            // render the final result (all images) to the framebuffer
            renderer.setRenderTarget( null );
            renderer.clear();
            fsMaterial.uniforms.tex.value = target[currentTarget].texture;
            renderer.render( fsScene, fsCamera );

            // update fps counter
            stats.update();

        }

    </script>
</body>
</html>
