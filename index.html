<!-- Needs webserver to run correctly -->
<!-- see https://threejs.org/docs/#manual/en/introduction/Installation for setup instructions (Option 1: Install with NPM and a build tool) -->
<!-- run: npx vite -->
<!-- open: http://localhost:5173/ -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebGL/Three.js Image Compositing</title>
    <meta charset="utf-8">
    <style>
        body {
          background-color: #ffffff;
        }
        .wrapperright { 
            background:#ffffff; 
            box-shadow: 1px 1px 10px #fcfcfc; 
            margin: right; 
            text-align: right; 
            float: right;
            position: relative;
            -webkit-border-radius: 5px;
            -moz-border-radius: 5px;
            border-radius: 5px;
            margin-bottom: 20px !important;
            width: 1500px;
            padding-top: 0px;
        }
        .wrapperleft { 
            background:#EFEFEF; 
            box-shadow: 1px 1px 10px #999; 
            margin: left; 
            text-align: left; 
            float: left;
            position: relative;
            -webkit-border-radius: 5px;
            -moz-border-radius: 5px;
            border-radius: 5px;
            margin-bottom: 20px !important;
            width: 600px;
            padding-top: 0px;
        }
        .scrolls { 
            overflow-x: scroll;
            overflow-y: hidden;
            height: 230px;
        white-space:nowrap
        } 
        .imageDiv img { 
            box-shadow: 1px 1px 10px #999; 
            margin: 2px;
            max-height: 50px;
            cursor: pointer;
        display:inline-block;
        *display:inline;
        *zoom:1;
        vertical-align:top;
        }
        .slidecontainer {
        width: 100%;
        }

        .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 25px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        -webkit-transition: .2s;
        transition: opacity .2s;
        }

        .slider:hover {
        opacity: 1;
        }

        .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        background: #04AA6D;
        cursor: pointer;
        }

        .slider::-moz-range-thumb {
        width: 25px;
        height: 25px;
        background: #04AA6D;
        cursor: pointer;
        }

        [slider] {
        width: 300px;
        position: relative;
        height: 5px;
        margin: 45px 0 10px 0;
        }

        [slider] > div {
        position: absolute;
        left: 13px;
        right: 15px;
        height: 5px;
        }
        [slider] > div > [inverse-left] {
        position: absolute;
        left: 0;
        height: 5px;
        border-radius: 10px;
        background-color: #CCC;
        margin: 0 7px;
        }

        [slider] > div > [inverse-right] {
        position: absolute;
        right: 0;
        height: 5px;
        border-radius: 10px;
        background-color: #CCC;
        margin: 0 7px;
        }


        [slider] > div > [range] {
        position: absolute;
        left: 0;
        height: 5px;
        border-radius: 14px;
        background-color: #2179d0;
        }

        [slider] > div > [thumb] {
        position: absolute;
        top: -7px;
        z-index: 2;
        height: 20px;
        width: 20px;
        text-align: left;
        margin-left: -11px;
        cursor: pointer;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        background-color: #FFF;
        border-radius: 50%;
        outline: none;
        }

        [slider] > input[type=range] {
        position: absolute;
        pointer-events: none;
        -webkit-appearance: none;
        z-index: 3;
        height: 14px;
        top: -2px;
        width: 100%;
        opacity: 0;
        }

        div[slider] > input[type=range]:focus::-webkit-slider-runnable-track {
        background: transparent;
        border: transparent;
        }

        div[slider] > input[type=range]:focus {
        outline: none;
        }

        div[slider] > input[type=range]::-webkit-slider-thumb {
        pointer-events: all;
        width: 28px;
        height: 28px;
        border-radius: 0px;
        border: 0 none;
        background: #0075ff;
        -webkit-appearance: none;
        }

        div[slider] > input[type=range]::-ms-fill-lower {
        background: transparent;
        border: 0 none;
        }

        div[slider] > input[type=range]::-ms-fill-upper {
        background: transparent;
        border: 0 none;
        }

        div[slider] > input[type=range]::-ms-tooltip {
        display: none;
        }

        [slider] > div > [sign] {
        opacity: 0;
        position: absolute;
        margin-left: -11px;
        top: -39px;
        z-index:3;
        background-color: #0075ff;
        color: #fff;
        width: 28px;
        height: 28px;
        border-radius: 28px;
        -webkit-border-radius: 28px;
        align-items: center;
        -webkit-justify-content: center;
        justify-content: center;
        text-align: center;
        }

        [slider] > div > [sign]:after {
        position: absolute;
        content: '';
        left: 0;
        border-radius: 16px;
        top: 19px;
        border-left: 14px solid transparent;
        border-right: 14px solid transparent;
        border-top-width: 16px;
        border-top-style: solid;
        border-top-color: #0075ff;
        }

        [slider] > div > [sign] > span {
        font-size: 12px;
        font-weight: 700;
        line-height: 28px;
        }

        [slider]:hover > div > [sign] {
        opacity: 1;
        }

        .dropdown {
        position: relative;
        font-size: 14px;
        color: #333;

        .dropdown-list {
            padding: 12px;
            background: #fff;
            position: absolute;
            top: 30px;
            left: 2px;
            right: 2px;
            box-shadow: 0 1px 2px 1px rgba(0, 0, 0, .15);
            transform-origin: 50% 0;
            transform: scale(1, 0);
            transition: transform .15s ease-in-out .15s;
            max-height: 66vh;
            overflow-y: scroll;
        }
        
        .dropdown-option {
            display: block;
            padding: 8px 12px;
            opacity: 0;
            transition: opacity .15s ease-in-out;
        }
        
        .dropdown-label {
            display: block;
            height: 30px;
            background: #fff;
            border: 1px solid #ccc;
            padding: 6px 12px;
            line-height: 1;
            cursor: pointer;
            
            &:before {
            content: '▼';
            float: right;
            }
        }
        
        &.on {
        .dropdown-list {
            transform: scale(1, 1);
            transition-delay: 0s;
            
            .dropdown-option {
                opacity: 1;
                transition-delay: .2s;
            }
            }
            
            .dropdown-label:before {
            content: '▲';
            }
        }
        
        [type="checkbox"] {
            position: relative;
            top: -1px;
            margin-right: 4px;
        }
        }

    </style>
    <script id="fullscreen-vert" type="x-shader/x-vertex">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 1.0, 1.0);
        }
    </script>
    <script id="fullscreen-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tex;

        void main() {
            vec3 diffuse = texture2D( tex, vUv ).rgb;
            gl_FragColor.rgb = diffuse;
            gl_FragColor.a = 1.0;
        }
    </script>
    <script id="blending-vert" type="x-shader/x-vertex">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="blending-frag" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D tex;
        uniform sampler2D bgTex;
        uniform float resX;
        uniform float resY;
        uniform float alpha;
        uniform int highlight;
        uniform int objDetect;
        uniform vec3 borderColor;
        uniform vec3 objectColor;

        void main() {
            // get color of current image
            vec3 color = texture2D( tex, vUv ).rgb;
            // texture coordinates of previous frame
            vec2 st = gl_FragCoord.xy / vec2(resX, resY);
            // get background color from texture (previous render target)
            vec3 bgColor = texture2D( bgTex, st).rgb;

            // this is a bit hacky (we assume that the background color is white)
            if( bgColor.x > 0.99 && bgColor.y > 0.99 && bgColor.z > 0.99 )
                // if the previous pixel has the background color: 
                //    render on top
                gl_FragColor.rgb = color;
            else
                // if the previous pixel does not have the background color: 
                //    blend with previous color
                gl_FragColor.rgb = bgColor * (1.0 - alpha) + color * alpha;

            // highlight pixels on the border of the image
            if (highlight == 1) {
                float borderX = 0.005;
                float borderY = (resX / resY) * borderX;
                float testX = 0.1;
                // check if pixel is on the border
                if( vUv.s < borderX || vUv.s > 1.0 - borderX || vUv.t < borderY || vUv.t > 1.0 - borderY )
                    gl_FragColor.rgb = borderColor;
                //if( vUv.s < testX )
                    //gl_FragColor.rgb = objectColor;
            }
            // draw object detection
            if (objDetect == 1) {
                float testX = 0.1;
                float testY = 0.1;
                if( testX - 0.01 < vUv.s && testX + 0.01 > vUv.s && testY - 0.01 < vUv.t && testY + 0.01 > vUv.t)
                    gl_FragColor.rgb = objectColor;
            }
            gl_FragColor.a = 1.0;
        }
    </script>
</head>
<body>
    <div class="wrapperleft">
    <video id="videoID" width="600" controls>
        <script type="module">
            //load video file
            var video_path = "/2023.03.29-17.39.21-main.mp4"
            document.querySelector('#videoID').src = video_path;
        </script>
        <source type="video/mp4">
        Your browser does not support HTML video.
    </video>
    <div slider id="slider-distance">
        <div>
          <div inverse-left style="width:70%;"></div>
          <div inverse-right style="width:70%;"></div>
          <div range style="left:0%;right:0%;"></div>
          <span thumb style="left:0%;"></span>
          <span thumb style="left:100%;"></span>
          <div sign style="left:0%;">
            <span id="value">0</span>
          </div>
          <div sign style="left:100%;">
            <span id="value">100</span>
          </div>
        </div>
        <input type="range" value="0" max="100" min="0" step="1" oninput="
        this.value=Math.min(this.value,this.parentNode.childNodes[5].value-1);
        let value = (this.value/parseInt(this.max))*100
        var children = this.parentNode.childNodes[1].childNodes;
        children[1].style.width=value+'%';
        children[5].style.left=value+'%';
        children[7].style.left=value+'%';children[11].style.left=value+'%';
        children[11].childNodes[1].innerHTML=this.value;" />
      
        <input type="range" value="100" max="100" min="0" step="1" oninput="
        this.value=Math.max(this.value,this.parentNode.childNodes[3].value-(-1));
        let value = (this.value/parseInt(this.max))*100
        var children = this.parentNode.childNodes[1].childNodes;
        children[3].style.width=(100-value)+'%';
        children[5].style.right=(100-value)+'%';
        children[9].style.left=value+'%';children[13].style.left=value+'%';
        children[13].childNodes[1].innerHTML=this.value;" />
    </div>
    Start Time - End Time
    <br></br>
    <label for="Name">Start Frame:</label>
    <input type="text" id="startFrame" name="startFrame">
    <label for="Name">End Frame:</label>
    <input type="text" id="endFrame" name="endFrame">
    <br></br>
    <h3>Panorama Tuning</h3>
    <label for="Name">Show every</label>
    <input type="text" id="dropout" name="dropout" placeholder="5">
    frames
    <br></br>
    <div class="slidecontainer">
        Alpha value:
        <input type="range" min="0" max="1" step="0.1" value="0.5" id="myRange"><span id="demo"></span>
    </div>
    <script>
        var slider = document.getElementById("myRange");
        var output = document.getElementById("demo");
        output.innerHTML = slider.value;
        
        slider.oninput = function() {
          output.innerHTML = this.value;
        }
    </script>
    <br></br>
    <div class="slidecontainer">
        Highlight frame:
        <input type="range" min="0" max="10" step="1" value="5" id="myRangeframe"><span id="demoframe"></span> 
        <label class="dropdown-option">
            <input type="checkbox" name="dropdown-group" value="None" />
            None
        </label>
    </div>
    <script>
        var sliderframe = document.getElementById("myRangeframe");
        var outputframe = document.getElementById("demoframe");
        outputframe.innerHTML = sliderframe.value;
        
        sliderframe.oninput = function() {
            outputframe.innerHTML = this.value;
        }
    </script>
    <br></br>
    <h3>Highlighting Objects</h3>
    <div class="slidecontainer">
        Confidence threshold:
        <input type="range" min="0" max="1" step="0.05" value="0.5" id="myRangeconf"><span id="democonf"></span>
    </div>
    <br></br>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Jar of nut butter" />
        Jar of nut butter
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Jar of jelly / jam" />
        Jar of jelly / jam
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="plate" />
        plate
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="paper towel" />
        paper towel
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="cutting board" />
        cutting board
    </label>
    <br></br>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="butter knife" />
        butter knife
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="person" />
        person
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="flour tortilla" />
        flour tortilla
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="~12-inch strand of dental floss toothpicks" />
        ~12-inch strand of dental floss toothpicks
    </label>
    <br></br>
    <h3>Highlighting Anomalies</h3>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Instances of duplicates" />
        Instances of duplicates 
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Instances of duplicates" />
        Disappear and return
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Instances of duplicates" />
        Overlapping objects 
    </label>
    <br></br>
    <h3>Expected Object Trajectory</h3>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Jar of nut butter EOL" />
        Jar of nut butter
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="Jar of jelly / jam EOL" />
        Jar of jelly / jam
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="plate EOL" />
        plate
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="paper towel EOL" />
        paper towel
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="cutting board EOL" />
        cutting board
    </label>
    <br></br>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="butter knife EOL" />
        butter knife
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="person EOL" />
        person
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="flour tortilla EOL" />
        flour tortilla
    </label>
    <label class="dropdown-option">
        <input type="checkbox" name="dropdown-group" value="~12-inch strand of dental floss toothpicks EOL" />
        ~12-inch strand of dental floss toothpicks
    </label>
    <br></br>
    <br></br>
    </div>
    <div class="wrapperright">
        <div class="scrolls">
            <img src='/frames_updated/0.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/1.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/2.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/3.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/4.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/5.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/6.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/7.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/8.png' style="width:380px;height:214px;" />
            <img src='/frames_updated/9.png' style="width:380px;height:214px;" />
        </div>
    </div>
    <br></br>
    <script type="module" id="stitch">
        import * as THREE from 'three';
        import Stats from 'three/addons/libs/stats.module.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // GUI parameters
        const params = {
            frameID: 0,
            objDetect: 0,
            color: 0xff0000,
            objColor: 0x00FF00,
            alpha: 0.5,
            saveImg: function() {
                var url = renderer.domElement.toDataURL("image/png");
                var link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('target', '_blank');
                link.setAttribute('download', 'panorama');
                link.click();
            },
        };

        // load json file
        var jsonData = await fetch("/corners_updated.json");
        var jsonCoords = await jsonData.json();
        
        // load images as textures
        var tex = [];
        var coordsX = [];
        var coordsY = [];
        var frameID = {};
        var startFrameIdx = document.getElementById("startFrame").value;
        var endFrameIdx = document.getElementById("endFrame").value;
        console.log(startFrameIdx)
        console.log(endFrameIdx)

        Object.entries(jsonCoords).forEach((entry) => {
            const [key, value] = entry;
            coordsX[key] = [ 
                value.corner_1_x,
                value.corner_2_x,
                value.corner_3_x,
                value.corner_4_x ];
            coordsY[key] = [ 
                value.corner_1_y,
                value.corner_2_y,
                value.corner_3_y,
                value.corner_4_y ];
            frameID[key] = value.frame_id;
            tex[key] = new THREE.TextureLoader().load( '/frames_updated/' + key.toString() + '.png' );
        });
        var imageCount = tex.length;
        
        // get min/max x/y values
        var minX = Math.min(...coordsX.map(item => Math.min.apply(null, item)));
        var maxX = Math.max(...coordsX.map(item => Math.max.apply(null, item)));
        var minY = Math.min(...coordsY.map(item => Math.min.apply(null, item)));
        var maxY = Math.max(...coordsY.map(item => Math.max.apply(null, item)));
        //console.log("X: " + (maxX - minX) + " Y: " + (maxY - minY))
        
        let renderer, camera, scene = [], material = [], controls, target = [];
        let stats;
        // scene, cam, and material for fullscreen quad rendering
        let fsScene, fsCamera, fsMaterial;

        // call initialize function only after loading image data
        init();
        animate();

        function init() {
            // fps counter (can be removed)
            stats = new Stats();
            document.body.appendChild( stats.dom );

            // WebGL renderer update
            renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );
            renderer.autoClear = false;
            renderer.setClearColor( 0xffffff, 1.0 );
            document.body.appendChild( renderer.domElement );

            // Create two render targets for ping-pong rendering
            setupRenderTargets();

            // Our scene
            setupScene();

            // Setup rendering step for fullscreen quad rendering (show render target texture)
            setupFullscreenQuadRendering();

            // resize render targets
            for (var i = 0; i < target.length; i++) {
                target[i].setSize( maxX - minX, maxY - minY );
            }
            // set renderer size to image size
            renderer.setSize( (maxX - minX) / 1.0, (maxY - minY) / 1.0 );
            
            // set up GUI
            const gui = new GUI( { width: 300 } );
            gui.add( params, 'frameID').name("Highlight Frame").min(0).max(imageCount).step(1);
            gui.add( params, 'objDetect').name("Object Detection").min(0).max(1).step(1);
            gui.addColor(params, 'color').name('Border Color');
            gui.addColor(params, 'objColor').name('Object Color');
            gui.add( params, 'alpha').name("Alpha").min(0.0).max(1.0).step(.01);
            gui.add( params, 'saveImg').name("Save Image");
            gui.open();
            
            //a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
            //a_sub = [[10, 11], [12, 13]]
            //a_sub_sz = [2, 2]
            //testAnchorY = 1
            //testAnchorX = 1
            //a[testAnchorY:testAnchorY+a_sub_sz[0], testAnchorX:testAnchorX+a_sub_sz[1]] = a_sub


            //console.log(a)
        }

        function setupRenderTargets() {
            // dispose of all previously declared render targets
            for (var i = 0; i < target.length; i++) {
                if ( target[i] ) target[i].dispose();
            }

            // first render target
            target[0] = new THREE.WebGLRenderTarget( maxX - minX, maxY - minY );
            target[0].texture.minFilter = THREE.LinearFilter;
            target[0].texture.magFilter = THREE.LinearFilter;

            // second render target
            target[1] = new THREE.WebGLRenderTarget( maxX - minX, maxY - minY );
            target[1].texture.minFilter = THREE.LinearFilter;
            target[1].texture.magFilter = THREE.LinearFilter;
        }

        function setupFullscreenQuadRendering() {
            // renders a texture on a full-screen qaud
            fsCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
            fsMaterial = new THREE.ShaderMaterial( {
                vertexShader: document.querySelector( '#fullscreen-vert' ).textContent.trim(),
                fragmentShader: document.querySelector( '#fullscreen-frag' ).textContent.trim(),
                uniforms: {
                    tex: { value: null }
                }
            } );
            const fsQuad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), fsMaterial );
            fsScene = new THREE.Scene();
            fsScene.add( fsQuad );
        }

        function setupScene() {
            
            camera = new THREE.OrthographicCamera( minX, maxX, minY, maxY, 0, -1 );
            
            // texture coordinates
            const uvcoords = new Float32Array( [
                0.0,  1.0,
                1.0,  0.0,
                1.0,  1.0,

                1.0,  0.0,
                0.0,  1.0,
                0.0,  0.0,
            ] );

            for( let i = 0; i < imageCount; i++) {
                scene[i] = new THREE.Scene();

                const vertices = new Float32Array( [
                    coordsX[i][0], coordsY[i][0], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 0
                    coordsX[i][2], coordsY[i][2], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 2
                    coordsX[i][1], coordsY[i][1], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 1

                    coordsX[i][2], coordsY[i][2], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 2
                    coordsX[i][0], coordsY[i][0], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 0
                    coordsX[i][3], coordsY[i][3], 1.0 - (i+1) * (1.0 / (tex.length+1)), // 3
                ] );

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                geometry.setAttribute( 'uv', new THREE.BufferAttribute( uvcoords, 2 ) );
                material[i] = new THREE.ShaderMaterial( {
                    vertexShader: document.querySelector( '#blending-vert' ).textContent.trim(),
                    fragmentShader: document.querySelector( '#blending-frag' ).textContent.trim(),
                    uniforms: {
                        tex: { value: tex[i] },
                        bgTex: { value: null },
                        resX: { value: maxX - minX },
                        resY: { value: maxY - minY },
                        alpha: { value: params.alpha },
                        highlight: { value: 0 },
                        objDetect: { value: 0 },
                        borderColor: { value: new THREE.Color(params.color)},
                        objectColor: { value: new THREE.Color(params.objColor)},
                    }
                } );
                material[i].side = THREE.DoubleSide;
                const quad = new THREE.Mesh( geometry, material[i] );
                scene[i].add( quad );
            }

        }

        function animate() {
            
            requestAnimationFrame( animate );

            // clear both render targets
            renderer.setRenderTarget( target[0] );
            renderer.clear();
            renderer.setRenderTarget( target[1] );
            renderer.clear();

            // render scene into target
            var currentTarget, lastTarget;
            for (var i = 0; i < imageCount; i++) {
                lastTarget = (i+1)%2;
                currentTarget = i%2;
                // set the current render target and clear it
                renderer.setRenderTarget( target[currentTarget] );
                renderer.clear();
                // render the previous results (full-screen quad)
                fsMaterial.uniforms.tex.value = target[lastTarget].texture;
                renderer.render( fsScene, fsCamera );
                // render the next image on top
                material[i].uniforms.bgTex.value = target[lastTarget].texture;
                material[i].uniforms.alpha.value = params.alpha;
                material[i].uniforms.highlight.value = (i == params.frameID - 1)? 1 : 0;
                material[i].uniforms.objDetect.value = params.objDetect;
                material[i].uniforms.borderColor.value = new THREE.Color(params.color);
                material[i].uniforms.objectColor.value = new THREE.Color(params.objColor);
                renderer.render( scene[i], camera );
            }

            // render the final result (all images) to the framebuffer
            renderer.setRenderTarget( null );
            renderer.clear();
            fsMaterial.uniforms.tex.value = target[currentTarget].texture;
            renderer.render( fsScene, fsCamera );

            // update fps counter
            stats.update();

        }
        
        /*
        function video_to_frames(video_path){
            var cap = cv2.VideoCapture(video_path)
            var frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            var output_arr = []
            var success, img = cap.read()
            while (frame_count >= 0){
                frame_count = frame_count - 1
                output_arr.append(img)
                success, img = cap.read()
            }
            return output_arr
        }

        function get_keypoints_descriptors(image){
            gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            sift = cv2.xfeatures2d.SIFT_create()
            kp, des = sift.detectAndCompute(gray_image, None)
            
            return(kp, des)
        }

        function feature_matching(des, des2){
            FLANN_INDEX_KDTREE = 1
            index_params = dict(algorithm = FLANN_INDEX_KDTREE, trees = 5)
            search_params = dict(checks = 50)
            flann = cv2.FlannBasedMatcher(index_params, search_params)
            matches = flann.knnMatch(des,des2,k=2)
            good = []
            for (m,n in matches){
                if (m.distance < 0.7*n.distance){
                    good.append(m)
                }
            }
            return good
        }

        function get_homography_matrix(image, image2, kp, kp2, good, MIN_MATCH_COUNT){
            if (good.length > MIN_MATCH_COUNT){
                src_pts = np.float32([ kp[m.queryIdx].pt for m in good ]).reshape(-1,1,2)
                dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)
                M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC,5.0)
                if (M is None){
                    M = None
                }
                else{
                    matchesMask = mask.ravel().tolist()
                    h = image.shape[0]
                    w = image.shape[1]
                    pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)
                    dst = cv2.perspectiveTransform(pts,M)
                }
            }
            else{
                print( "Not enough matches are found - {}/{}".format(good.length, MIN_MATCH_COUNT) )
                matchesMask = None
                M = []
            }
            return M
        }

        //need to take the python stuff out of this
        function rgb_to_rgba(im){
            im = Image.fromarray((im).astype(np.uint8))
            im = im.convert('RGBA')
            im = np.asarray(im)
            return im
        }

        //I've been using background_width = 2280 and background_height = 1284 (3 times the width and height of one frame) as the default
        function frames_and_corners(indices, main_frame_arr, background_width, background_height){
            final_pano_frames = []
            output_min_x = 0
            output_max_x = 0
            output_min_y = 0
            output_max_y = 0

            for (let f = 1; f < indices.length; f++){
            
                if (final_pano_frames.length == 0){ 
                src = rgb_to_rgba(main_frame_arr[indices[1]])
                dst = rgb_to_rgba(main_frame_arr[indices[0]])

                dst_sz = [dst.length, dst[0].length, dst[0][0].length]
                pad_sz = [dst_sz[0] * 3, dst_sz[1] * 3, 4]
                anchorX = dst_sz[1]-1 
                anchorY = dst_sz[0]-1

                output_min_x = anchorX
                output_max_x = anchorX + dst_sz[1]-1
                output_min_y = anchorY
                output_max_y = anchorY + dst_sz[0]-1

                dst_pad = np.zeros(pad_sz, dtype=np.uint8)
                dst_pad[anchorY:anchorY+dst_sz[0], anchorX:anchorX+dst_sz[1]] = dst

                //warp src into correct place
                kp_src, des_src = get_keypoints_descriptors(src)
                kp_dst, des_dst = get_keypoints_descriptors(dst)
                matches = feature_matching(des_src, des_dst)
                transf = get_homography_matrix(src, dst, kp_src, kp_dst, matches, 4)

                src_h, src_w = src.shape[:2]
                lin_homg_pts = np.array([[0, src_w, src_w, 0], [0, 0, src_h, src_h], [1, 1, 1, 1]])

                trans_lin_homg_pts = transf.dot(lin_homg_pts)
                trans_lin_homg_pts /= trans_lin_homg_pts[2,:]

                // add translation to the transformation matrix to shift to positive values
                transl_transf = np.eye(3,3)
                transl_transf[0,2] += anchorX
                transl_transf[1,2] += anchorY
                new_transf = transl_transf.dot(transf)
                new_transf /= new_transf[2,2]

                //take the corners of src and dst as polygons in shapely
                pts = np.float32([ [0,0],[src_w, 0],[src_w, src_h],[0, src_h] ]).reshape(-1,1,2)
                dst_pts = cv2.perspectiveTransform(pts,new_transf)

                src_polygon = Polygon([(dst_pts[0][0][0], dst_pts[0][0][1]), (dst_pts[1][0][0], dst_pts[1][0][1]), (dst_pts[2][0][0], dst_pts[2][0][1]), (dst_pts[3][0][0], dst_pts[3][0][1])])
                src_polygon_x,src_polygon_y = src_polygon.exterior.xy
                df['frame_id'][0] = indices[0]
                df['corner_1_x'][0] = 0
                df['corner_1_y'][0] = 0
                df['corner_2_x'][0] = src_w
                df['corner_2_y'][0] = 0
                df['corner_3_x'][0] = src_w
                df['corner_3_y'][0] = src_h
                df['corner_4_x'][0] = 0
                df['corner_4_y'][0] = src_h

                df['frame_id'][1] = indices[1]
                df['corner_1_x'][1] = src_polygon_x[0]
                df['corner_1_y'][1] = src_polygon_y[0]
                df['corner_2_x'][1] = src_polygon_x[1]
                df['corner_2_y'][1] = src_polygon_y[1]
                df['corner_3_x'][1] = src_polygon_x[2]
                df['corner_3_y'][1] = src_polygon_y[2]
                df['corner_4_x'][1] = src_polygon_x[3]
                df['corner_4_y'][1] = src_polygon_y[3]

                dst_polygon = Polygon([(anchorX,anchorY),(anchorX+760,anchorY),(anchorX+760,anchorY+428),(anchorX,anchorY+428)])

                //get overlap
                overlap = src_polygon.intersection(dst_polygon)
                overlap_x,overlap_y = overlap.exterior.xy
                
                //warp src
                warped_src = cv2.warpPerspective(src, new_transf, (pad_sz[1],pad_sz[0]), borderMode=cv2.BORDER_CONSTANT, borderValue=(0, 0, 0, 0))

                //use overlap_x, overlap_y to create "bounding box" around src polygon, jump to that bounding box and only check points inside of it for blending while compositing
                //compositing dst_pad and warped_src
                //keep dst_pad or warped_src values for pixels with only one or the other
                //if a pixel is inside the overlap polygon, blend dst_pad and warped_src with equal weights
                dst_pad_copy = dst_pad.copy()
                min_x = math.floor(min(src_polygon_x))
                max_x = math.floor(max(src_polygon_x))
                min_y = math.floor(min(src_polygon_y))
                max_y = math.floor(max(src_polygon_y))

                output_min_x = min(output_min_x, min_x)
                output_max_x = max(output_max_x, max_x)
                output_min_y = min(output_min_y, min_y)
                output_max_y = max(output_max_y, max_y)

                for i in range(max_y - min_y):
                    for j in range(max_x - min_x):
                    current_point = Point(min_x + j, min_y + i)
                    if overlap.contains(current_point):
                        dst_pad_copy[min_y + i][min_x + j] = [(dst_pad_copy[min_y + i][min_x + j][0] / 2 + warped_src[min_y + i][min_x + j][0] / 2), (dst_pad_copy[min_y + i][min_x + j][1] / 2 + warped_src[min_y + i][min_x + j][1] / 2), (dst_pad_copy[min_y + i][min_x + j][2] / 2 + warped_src[min_y + i][min_x + j][2] / 2), 255]
                    elif src_polygon.contains(current_point):
                        dst_pad_copy[min_y + i][min_x + j] = warped_src[min_y + i][min_x + j]
                
                //save frames
                final_pano_frames.append(dst_pad) //"pano" with only first frame/dst
                final_pano_frames.append(dst_pad_copy) //pano with first two frames (src and dst)

                cv2.imwrite("/content/frames/" + str(0) + ".png", main_frame_arr[0])
                cv2.imwrite("/content/frames/" + str(1) + ".png", main_frame_arr[1])

                //cv2.imwrite("/content/final_pano_frames/" + str(0) + ".png", final_pano_frames[0][anchorY:anchorY+dst_sz[0]:1, anchorX:anchorX+dst_sz[1]:1])
                //cv2.imwrite("/content/final_pano_frames/" + str(1) + ".png", final_pano_frames[1][output_min_y:output_max_y+1:1, output_min_x:output_max_x+1:1])
                }

                else{
                prev_dst_pad_copy = dst_pad_copy.copy()
                src = rgb_to_rgba(main_frame_arr[indices[f]])
                dst = prev_dst_pad_copy

                //warp src into correct place
                kp_src, des_src = get_keypoints_descriptors(src)
                kp_dst, des_dst = get_keypoints_descriptors(dst)
                matches = feature_matching(des_src, des_dst)
                transf = get_homography_matrix(src, dst, kp_src, kp_dst, matches, 4)

                //take the corners of src and dst as polygons in shapely
                src_h, src_w = src.shape[:2]
                pts = np.float32([ [0,0],[src_w, 0],[src_w, src_h],[0, src_h] ]).reshape(-1,1,2)
                dst_pts = cv2.perspectiveTransform(pts,transf)

                polygons = [src_polygon, dst_polygon]
                dst_polygon = unary_union(polygons)

                src_polygon = Polygon([(dst_pts[0][0][0], dst_pts[0][0][1]), (dst_pts[1][0][0], dst_pts[1][0][1]), (dst_pts[2][0][0], dst_pts[2][0][1]), (dst_pts[3][0][0], dst_pts[3][0][1])])
                src_polygon_x,src_polygon_y = src_polygon.exterior.xy
                df['frame_id'][f] = indices[f]
                df['corner_1_x'][f] = src_polygon_x[0]
                df['corner_1_y'][f] = src_polygon_y[0]
                df['corner_2_x'][f] = src_polygon_x[1]
                df['corner_2_y'][f] = src_polygon_y[1]
                df['corner_3_x'][f] = src_polygon_x[2]
                df['corner_3_y'][f] = src_polygon_y[2]
                df['corner_4_x'][f] = src_polygon_x[3]
                df['corner_4_y'][f] = src_polygon_y[3]

                //get overlap
                overlap = src_polygon.intersection(dst_polygon)
                overlap_x,overlap_y = overlap.exterior.xy

                //warp src
                warped_src = cv2.warpPerspective(src, transf, (prev_dst_pad_copy.shape[1],prev_dst_pad_copy.shape[0]), borderMode=cv2.BORDER_CONSTANT, borderValue=(0, 0, 0, 0))

                //compositing
                min_x = math.floor(min(src_polygon_x))
                max_x = math.floor(max(src_polygon_x))
                min_y = math.floor(min(src_polygon_y))
                max_y = math.floor(max(src_polygon_y))

                output_min_x = min(output_min_x, min_x)
                output_max_x = max(output_max_x, max_x)
                output_min_y = min(output_min_y, min_y)
                output_max_y = max(output_max_y, max_y)

                for i in range(max_y - min_y):
                    for j in range(max_x - min_x):
                    current_point = Point(min_x + j, min_y + i)
                    if overlap.contains(current_point):
                        prev_dst_pad_copy[min_y + i][min_x + j] = [(prev_dst_pad_copy[min_y + i][min_x + j][0] / 2 + warped_src[min_y + i][min_x + j][0] / 2), (prev_dst_pad_copy[min_y + i][min_x + j][1] / 2 + warped_src[min_y + i][min_x + j][1] / 2), (prev_dst_pad_copy[min_y + i][min_x + j][2] / 2 + warped_src[min_y + i][min_x + j][2] / 2), 255]
                    elif src_polygon.contains(current_point):
                        prev_dst_pad_copy[min_y + i][min_x + j] = warped_src[min_y + i][min_x + j]
                
                //save
                final_pano_frames.append(prev_dst_pad_copy)
                }
            }
            return final_pano_frames
        }
        */

    </script>
</body>
</html>